//207. 课程表
class Solution {
public:
    struct Graph{
        int label;
        vector<struct Graph*>neighbor;
        Graph(int c):label(c),neighbor(){}
    };
    
    bool canFinish(int n, vector<pair<int, int>>& p) {
        vector<int>visited(n,-1);
        vector<struct Graph*>G;
        for(int i=0;i<n;++i)
            G.push_back(new Graph(i));
        
        for(int i=0;i<p.size();++i){
            auto e1=p[i].first,e2=p[i].second;
            G[e2]->neighbor.push_back(G[e1]);    
        }
        for(int i=0;i<n;++i)
            if(visited[i]==-1 && !dfs(G[i],visited))
                return false;
               
        for(int i=0;i<n;++i)
            delete G[i];
        return true;
    }
private:
    bool dfs(struct Graph* g,vector<int>&visited){
        visited[g->label]=0;
        for(int i=0;i<(g->neighbor).size();++i){
            if(visited[g->neighbor[i]->label]==-1){
                if(!dfs(g->neighbor[i],visited))
                    return false;
            }else if(visited[g->neighbor[i]->label]==0)
                return false;
        }
        visited[g->label]=1;
        return true;
    }
};
